<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Canvas 2D Void Mobile</title>
    <style>
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100vh; 
            height: 100dvh;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background-color: #000; 
            overflow: hidden;
            position: fixed;
            touch-action: none;
        }
        
        canvas { 
            width: 100vw; 
            height: 100vh;
            height: 100dvh;
            display: block;
            touch-action: none;
            background: radial-gradient(ellipse at center, #001122 0%, #000000 100%);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.7;
            z-index: 10;
        }
        
        #fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.3);
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            display: none;
        }
        
        #touch-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            text-align: center;
            z-index: 100;
            animation: fadeInOut 3s ease-in-out infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">Initializing particles...</div>
    <div id="fps-counter">FPS: --</div>
    <div id="touch-indicator">Touch to interact</div>

    <script>
        // ===================================================================================
        //  MOBILE DEVICE DETECTION & OPTIMIZATION
        // ===================================================================================
        
        function getMobileOptimizations() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isLowEnd = navigator.hardwareConcurrency <= 4 || navigator.deviceMemory <= 4;
            const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
            
            return {
                isMobile,
                isLowEnd,
                pixelRatio,
                particleCount: isLowEnd ? 1000 : isMobile ? 2000 : 5000,
                trailLength: isMobile ? 0.95 : 0.98, // Shorter trails on mobile for performance
                useOptimizedRendering: isMobile
            };
        }

        // ===================================================================================
        //  PARTICLE SYSTEM VOID: Cast your particle logic here.
        // ===================================================================================
        
        class ParticleSystem {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.options = { ...getMobileOptimizations(), ...options };
                
                this.particles = [];
                this.time = 0;
                this.touchX = 0;
                this.touchY = 0;
                this.isTouch = false;
                
                this.initParticles();
                this.setupEventListeners();
            }
            
            initParticles() {
                this.particles = [];
                for (let i = 0; i < this.options.particleCount; i++) {
                    this.particles.push({
                        id: i,
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: 0,
                        vy: 0,
                        life: Math.random(),
                        size: Math.random() * 2 + 0.5,
                        hue: Math.random() * 60 + 200, // Blue-cyan range
                        alpha: Math.random() * 0.8 + 0.2
                    });
                }
            }
            
            setupEventListeners() {
                // Touch events for mobile interaction
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.touchX = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
                    this.touchY = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
                    this.isTouch = true;
                    document.getElementById('touch-indicator').style.display = 'none';
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.touchX = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
                    this.touchY = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.isTouch = false;
                });
                
                // Mouse events for desktop
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.touchX = (e.clientX - rect.left) * (this.canvas.width / rect.width);
                    this.touchY = (e.clientY - rect.top) * (this.canvas.height / rect.height);
                    this.isTouch = true;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.isTouch = false;
                });
            }
            
            updateParticle(particle) {
                // The parable kernel mathematics adapted for Canvas 2D
                const i = particle.id;
                const y = i / 470.0;
                const k = (4.0 + Math.sin(y * 7.0 - this.time) * 3.0) * Math.cos(i / 78.0);
                const e = y / 8.0 - 13.0;
                const d = Math.sqrt(k * k + e * e);
                
                const q = 2.0 * Math.sin(k * 2.0) + 0.3 / Math.max(Math.abs(k), 0.001) + 
                         y / 8.0 * k * (2.0 + Math.sin(y - d * 3.0 + this.time * 2.0));
                
                const m = i & 7;
                const c = d - this.time + m * 0.4;
                
                const baseX = q * Math.cos(c) + 40.0 * Math.cos(c + m * 0.7) + 200.0;
                const baseY = q * Math.sin(c) + d * 46.0 - 300.0;
                
                // Normalize to canvas coordinates
                const aspect = this.canvas.width / this.canvas.height;
                particle.x = ((baseX / this.canvas.width) * 2.0 - 1.0) * aspect * this.canvas.width * 0.5 + this.canvas.width * 0.5;
                particle.y = (baseY / this.canvas.height) * 2.0 * this.canvas.height * 0.5 + this.canvas.height * 0.5;
                
                // Touch interaction
                if (this.isTouch) {
                    const dx = this.touchX - particle.x;
                    const dy = this.touchY - particle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = Math.max(0, 100 - dist) * 0.001;
                    
                    particle.x += dx * force;
                    particle.y += dy * force;
                }
                
                // Update particle properties
                particle.life += 0.01;
                particle.alpha = 0.5 + 0.3 * Math.sin(particle.life * 2);
                particle.size = 0.5 + 1.5 * (0.5 + 0.5 * Math.sin(particle.life * 3));
            }
            
            render() {
                // Trail effect for smooth motion
                this.ctx.fillStyle = `rgba(0, 1, 8, ${1 - this.options.trailLength})`;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render particles
                for (const particle of this.particles) {
                    this.updateParticle(particle);
                    
                    // Skip particles outside canvas
                    if (particle.x < -10 || particle.x > this.canvas.width + 10 || 
                        particle.y < -10 || particle.y > this.canvas.height + 10) {
                        continue;
                    }
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.alpha;
                    
                    // Create gradient for each particle
                    const gradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    gradient.addColorStop(0, `hsl(${particle.hue}, 80%, 80%)`);
                    gradient.addColorStop(0.5, `hsl(${particle.hue}, 60%, 50%)`);
                    gradient.addColorStop(1, `hsl(${particle.hue}, 40%, 20%)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                this.time += 0.016; // ~60fps time step
            }
            
            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * this.options.pixelRatio;
                this.canvas.height = rect.height * this.options.pixelRatio;
                this.ctx.scale(this.options.pixelRatio, this.options.pixelRatio);
            }
        }

        // ===================================================================================
        //  SETUP VOID: Cast your initialization logic here.
        // ===================================================================================
        
        const RENDER_OPTIONS = {
            // Particle count automatically adjusted based on device
            // Trail length optimized for mobile performance
            // Touch interaction enabled
            backgroundColor: '#000108',
            showFPS: false // Set to true for debugging
        };

        function setup() {
            const canvas = document.getElementById('canvas');
            const loading = document.getElementById('loading');
            
            // Initialize particle system
            const particleSystem = new ParticleSystem(canvas, RENDER_OPTIONS);
            
            // Handle resize
            function handleResize() {
                particleSystem.resize();
            }
            
            handleResize();
            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(handleResize, 100);
            });
            
            loading.style.display = 'none';
            
            return particleSystem;
        }

        // ===================================================================================
        //  MOBILE-OPTIMIZED CORE FRAMEWORK
        // ===================================================================================
        
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                const fpsCounter = document.getElementById('fps-counter');
                if (RENDER_OPTIONS.showFPS) {
                    fpsCounter.style.display = 'block';
                    fpsCounter.textContent = `FPS: ${fps}`;
                }
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        function main() {
            const particleSystem = setup();
            let isVisible = true;
            
            // Battery optimization - pause when not visible
            document.addEventListener('visibilitychange', () => {
                isVisible = !document.hidden;
            });
            
            function animate() {
                if (isVisible) {
                    updateFPS();
                    particleSystem.render();
                }
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }
        
        // Prevent zoom on double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
